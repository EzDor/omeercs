# Memory Match Game Template

## Purpose
A full 3D memory card game rendered in Three.js with real 3D card meshes, spatial lighting, and an immersive scene. Players flip cards in a WebGL-rendered environment to find matching pairs. The Three.js scene code is generated by the Claude Agent SDK based on the game configuration, producing a self-contained bundle with PBR materials, particle effects, and post-processing.

## User Stories

### P1 (Critical)
- US1: As a player, I want to tap cards to flip them over in 3D so that I can see what's underneath
- US2: As a player, I want matching pairs to stay revealed with a glowing effect so that I can see my progress
- US3: As a campaign creator, I want to configure the cards (images, number of pairs) so that the game matches my campaign

### P2 (Important)
- US4: As a player, I want a move counter or timer so that I have a goal to beat
- US5: As a player, I want smooth 3D card flip animations with physics-based easing so that the game feels immersive
- US6: As a campaign creator, I want to set win conditions (max moves, time limit) so that I can control difficulty

### P3 (Nice to Have)
- US7: As a player, I want a hint button that briefly shows all cards so that I can get unstuck
- US8: As a campaign creator, I want difficulty levels (easy/medium/hard with different grid sizes)

## Requirements

### Game Mechanics
- REQ1: Grid of face-down 3D card meshes arranged in world space (configurable: 2x3, 3x4, 4x4, 4x5)
- REQ2: Raycaster-based tap/click detection to flip a card
- REQ3: Two cards flipped: if match, stay revealed with emissive glow and particle burst; if no match, flip back after configurable delay
- REQ4: Game ends when all pairs matched (win) or limit exceeded (lose)
- REQ5: Prevent flipping more than 2 cards simultaneously

### 3D Scene
- REQ6: THREE.Scene containing a grid of card meshes on a 3D table/surface model
- REQ7: PerspectiveCamera positioned above the card grid with configurable tilt angle (isometric-style or top-down)
- REQ8: Ambient light for base illumination plus spot lights that highlight flipped cards
- REQ9: PBR materials on cards: glossy front face (low roughness, moderate metalness) and matte back face (high roughness)
- REQ10: 3D table/surface model beneath the cards with its own PBR material
- REQ11: Background environment via HDRI environment map or procedural skybox

### Card Flip Animation
- REQ12: Real 3D rotation around the Y-axis using Three.js (GSAP or THREE.AnimationMixer), not CSS transforms
- REQ13: Physics-based easing with slight bounce at the end of the flip
- REQ14: Particle burst effect (THREE.Points with custom ShaderMaterial) when a pair is matched
- REQ15: Matched cards glow using emissive material properties
- REQ16: Camera performs a subtle zoom toward the pair being checked, then eases back

### Card Display
- REQ17: Card back shows uniform texture mapped onto the back face of the 3D mesh
- REQ18: Card front shows unique brand image texture per pair mapped onto the front face
- REQ19: Matched pairs have persistent emissive glow effect

### Post-Processing
- REQ20: Bloom pass on matched pairs to create a luminous glow
- REQ21: Subtle depth-of-field effect with cards in focus and table edges softly blurred

### Win Conditions
- REQ22: Move limit mode: win if all pairs matched in X moves
- REQ23: Time limit mode: win if all pairs matched in X seconds
- REQ24: Free mode: no limit, track score for leaderboard

### Configuration Schema
```typescript
interface MemoryMatchConfig {
  grid_size: GridSize;
  card_pairs: CardPair[];
  card_back_texture_url: string;
  win_condition: WinConditionConfig;
  flip_delay_ms: number;
  scene: SceneConfig;
  card_material: CardMaterialConfig;
  grid_layout: GridLayoutConfig;
  post_processing: PostProcessingConfig;
}

type GridSize = '2x3' | '3x4' | '4x4' | '4x5';

interface CardPair {
  pair_id: string;
  face_texture_url: string;
  label?: string;
}

interface SceneConfig {
  camera: CameraConfig;
  lighting: LightingConfig;
  environment_map_url?: string;
  background_color?: string;
}

interface CameraConfig {
  fov: number;
  position: { x: number; y: number; z: number };
  look_at: { x: number; y: number; z: number };
  tilt_angle_deg: number;
  zoom_on_check: number;
}

interface LightingConfig {
  ambient_color: string;
  ambient_intensity: number;
  spot_color: string;
  spot_intensity: number;
  spot_position: { x: number; y: number; z: number };
  flip_highlight_intensity: number;
}

interface CardMaterialConfig {
  front_metalness: number;
  front_roughness: number;
  back_metalness: number;
  back_roughness: number;
  matched_emissive_color: string;
  matched_emissive_intensity: number;
}

interface GridLayoutConfig {
  card_width: number;
  card_height: number;
  card_depth: number;
  spacing_x: number;
  spacing_z: number;
  grid_center: { x: number; y: number; z: number };
}

interface PostProcessingConfig {
  bloom_enabled: boolean;
  bloom_strength: number;
  bloom_radius: number;
  bloom_threshold: number;
  dof_enabled: boolean;
  dof_focus_distance: number;
  dof_aperture: number;
  dof_max_blur: number;
}

interface WinConditionConfig {
  type: 'moves' | 'time' | 'none';
  limit?: number;
  prize_tiers?: PrizeTier[];
}

interface PrizeTier {
  max_moves?: number;
  max_time_sec?: number;
  prize_label: string;
  prize_code?: string;
  is_winner: boolean;
}
```

### Asset Slots
| Slot ID | Type | Required | Description |
|---------|------|----------|-------------|
| card_model | model_3d (GLB) | No | GLB card mesh (fallback: generated BoxGeometry) |
| table_model | model_3d (GLB) | No | GLB table/surface model for cards to sit on |
| logo_model_3d | model_3d (GLB) | No | 3D brand logo model displayed in scene |
| card_back_texture | texture | Yes | Texture mapped onto card back faces |
| card_face_1 through card_face_10 | texture | No | Textures mapped onto card front faces per pair |
| environment_map | texture (HDR) | No | HDR environment map for scene reflections and skybox |
| bgm_track | audio | No | Background music |
| flip_sound | audio | No | Card flip sound |
| match_sound | audio | No | Sound when pair matched |
| no_match_sound | audio | No | Sound when no match |
| win_sound | audio | Yes | Victory sound |
| lose_sound | audio | No | Time/move limit exceeded |

### Grid Calculations
| Grid Size | Cards | Pairs | Minimum Moves |
|-----------|-------|-------|---------------|
| 2x3 | 6 | 3 | 3 |
| 3x4 | 12 | 6 | 6 |
| 4x4 | 16 | 8 | 8 |
| 4x5 | 20 | 10 | 10 |

### Responsive Behavior
- REQ25: WebGL canvas scales to fill viewport while maintaining aspect ratio
- REQ26: Camera frustum adjusts on resize to keep all cards visible
- REQ27: Raycaster hit targets remain accurate across viewport sizes for touch and pointer input

### Outcome Handling
- REQ28: Emit `gameComplete` event when finished
- REQ29: Event payload: `{ won: boolean, moves: number, timeMs: number, prizeTier?: PrizeTier }`
- REQ30: Results screen shows moves, time, and prize (rendered as HTML overlay on top of the WebGL canvas)

## Technical Implementation
- Framework: Three.js (WebGL renderer) with scene code generated by Claude Agent SDK
- Scene: THREE.Scene with a grid of 3D card meshes (BoxGeometry or loaded GLB via GLTFLoader) positioned on a table surface
- Interaction: THREE.Raycaster for card tap/click detection in 3D space, pointer events mapped to normalized device coordinates
- Animation: GSAP for card flip rotations with physics-based easing, THREE.AnimationMixer for GLB-embedded animations
- Particles: THREE.Points with BufferGeometry and custom ShaderMaterial for match burst effects
- Materials: THREE.MeshStandardMaterial with PBR properties (metalness, roughness, emissive) and texture maps
- Post-Processing: EffectComposer with UnrealBloomPass and BokehPass
- Audio: Web Audio API via THREE.AudioListener and THREE.Audio
- State: Track flipped cards, matched pairs, move count in plain JS state object
- Shuffle: Fisher-Yates algorithm for card placement
- Asset Loading: GLTFLoader for GLB models, TextureLoader for images, RGBELoader for HDR environment maps
- Compression: KTX2 textures via KTX2Loader with basis_transcoder for GPU-compressed textures

## Performance
- Target: 60fps on mid-range mobile devices
- Instanced rendering (THREE.InstancedMesh) for identical card back faces to reduce draw calls
- Compressed textures (KTX2 with Basis Universal) for reduced GPU memory and faster loading
- Geometry reuse: single BoxGeometry shared across all card meshes
- Texture atlasing for card face images where possible
- Dispose unused textures and geometries on scene teardown to prevent memory leaks

## Dependencies
- Depends on: Template System (manifest, config injection, asset slots), Three.js runtime, Claude Agent SDK for code generation
- Required by: bundle_game_template skill when template_id = "memory_match"

## Success Criteria
- [ ] Three.js scene renders at 60fps on target devices
- [ ] Cards flip with real 3D Y-axis rotation and physics-based bounce easing
- [ ] PBR materials render correctly with glossy fronts and matte backs
- [ ] Matching pairs detection works correctly
- [ ] Non-matching pairs flip back after configured delay
- [ ] Particle burst fires on successful match
- [ ] Matched cards glow with emissive material and bloom post-processing
- [ ] Camera zoom effect triggers when checking a pair
- [ ] Raycaster interaction works reliably for touch and pointer input
- [ ] Move counter increments correctly
- [ ] Timer counts accurately
- [ ] Win/lose conditions trigger at correct thresholds
- [ ] Grid layouts work for all supported sizes (2x3, 3x4, 4x4, 4x5)
- [ ] GLB card and table models load and display when provided
- [ ] Environment map renders as scene background and provides reflections
- [ ] Audio plays correctly for flip, match, no-match, win, and lose events
- [ ] Works offline after initial load
- [ ] Touch-friendly on mobile devices
